# -*- coding: utf-8 -*-
"""Nigam_A_Lab2.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L9Scn_3GtpS5nyJhCL3rvznKS5rr9Cue
"""

# Name: Arul Nigam
# Period: 3

import random

def getInitialState():
   x = "_12345678"
   l = list(x)
   random.shuffle(l)
   y = ''.join(l)
   return y
   
'''precondition: i<j
   swap characters at position i and j and return the new state'''
def swap(state, i, j):
    stateList = list(state) # save the string as a list to make operations easier
    stateList[i], stateList[j] = stateList[j], stateList[i] # switch the values at i and j
    return ''.join(stateList) # join the list into a string and return

'''Generate a list which hold all children of the current state
   and return the list'''
def generate_children(state):
   ret = []
   i = state.index("_")
   if i not in [6, 7, 8]: # can be swapped with below
     ret.append(swap(state, i, i + 3)) # swap down
   if i not in [0, 3, 6]: # can be swapped with left
     ret.append(swap(state, i - 1, i)) # swap left
   if i not in [2, 5, 8]: # can be swapped with right
     ret.append(swap(state, i, i + 1)) # swap right
   if i not in [0, 1, 2]: # can be swapped with above
     ret.append(swap(state, i - 3, i)) # swap up
   return ret # return whatever children were added...there should be at least 2 on a 3x3 board

def display_path(n, explored): #key: current, value: parent
   l = []
   while explored[n] != "s": #"s" is initial's parent
      l.append(n)
      n = explored[n]
   print ()
   l = l[::-1]
   for i in l:
      print (i[0:3], end = "   ")
   print ()
   for j in l:
      print (j[3:6], end = "   ")
   print()
   for k in l:
      print (k[6:9], end = "   ")
   print ("\n\nThe shortest path length is :", len(l))
   return ""

'''Find the shortest path to the goal state "_12345678" and
   returns the path by calling generate_path() function to print all steps.
   You can make other helper methods, but you must use dictionary for explored.'''
def BFS(initial_state):
    explored, frontier = {}, [initial_state, "s"]
    while frontier: # while frontier is not empty
        state = frontier.pop(0) # state is the first element
        parent = frontier.pop(0) # parent is the second element
        if state not in explored: # if this is a new (unexplored) state on the frontier
            explored[state] = parent # add a new key:value pair (child:parent)...similar to a listNode (value + pointer)
            children = generate_children(state) # capture the list of children
            for child in children: # for each of the children of the current node...
                frontier.append(child) # ...add the child to the frontier...
                frontier.append(state) # and follow the child with the parent (state)
        if state == "_12345678": # if you've reached the goal_state:
            display_path(state, explored) # display the path
            return state # and you're done! return the state
    return ("No solution") # if you expanded everything and never reached the goal_state, then there is no solution

'''Find the shortest path to the goal state "_12345678" and
   returns the path by calling generate_path() function to print all steps.
   You can make other helper methods, but you must use dictionary for explored.'''
def DFS(initial_state):
    explored, frontier = {}, [initial_state, "s"]
    while frontier: # while frontier is not empty
        parent = frontier.pop() # parent is the last element
        state = frontier.pop() # state is the second to last element
        if state not in explored: # if this is a new (unexplored) state on the frontier
            explored[state] = parent # add a new key:value pair (child:parent)...similar to a listNode (value + pointer)
            children = generate_children(state) # capture the list of children
            for child in children: # for each of the children of the current node...
                frontier.append(child) # ...add the child to the frontier...
                frontier.append(state) # and follow the child with the parent (state)
        if state == "_12345678": # if you've reached the goal_state:
            display_path(state, explored) # display the path
            return state # and you're done! return the state
    return ("No solution") # if you expanded everything and never reached the goal_state, then there is no solution

def main():
   initial = getInitialState()
   print ("BFS start with:\n", initial[0:3], "\n", initial[3:6], "\n", initial[6:], "\n")
   print (BFS(initial))
   print ("DFS start with:\n", initial[0:3], "\n", initial[3:6], "\n", initial[6:], "\n")
   print (DFS(initial))

if __name__ == '__main__':
    main()
